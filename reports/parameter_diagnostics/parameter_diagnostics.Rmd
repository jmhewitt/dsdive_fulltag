---
title: "Posterior diagnostics for model parameters"
output: 
  pdf_document: 
    toc: yes
header-includes:
  - \usepackage{booktabs}
params:
    tgt_dir: nim_fit
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, message = FALSE, cache = FALSE, 
                      dev = 'png', dpi = 300)
```

```{r paths}
paths = list(
  # location of mcmc output files
  # path_out = 'output/mcmc/nim_fit ',
  # path_out = 'output/mcmc/nim_fit_individual_2ac8c401/',
  path_out = file.path('output', 'mcmc', params$tgt_dir),
  # identifying characteristics of key output files
  active_samplers = '*active_samplers.rds',
  param_sample_pattern = '*parameter_samples_[0-9]+',
  param_sample_column_labels = '*parameter_samples_column_labels.rds'
)
```

```{r mcmc_input}
nim_pkg = readRDS(dir(path = paths$path_out, pattern = 'pkg', 
                      full.names = TRUE))
```

```{r parameter_groups}
# load targets of active samplers
active_samplers = unlist(readRDS(
  dir(path = paths$path_out, pattern = paths$active_samplers, full.names = TRUE)
))

# identify common parameter names, excluding stages
parameter_families = setdiff(
  unique(gsub(pattern = '\\[.*\\]', replacement = '', x = active_samplers)),
  'stages'
)

# # associate actively sampled targets with the common parameter names
# sampler_groups = lapply(parameter_families, function(pfam) {
#   grep(pattern = paste(pfam, '\\[', sep = ''), 
#        x = active_samplers, value = TRUE)
# })
# names(sampler_groups) = parameter_families
# sampler_groups = sampler_groups[order(names(sampler_groups))]


rm(active_samplers)
```

```{r output_files}
param_sample_files = dir(path = paths$path_out, 
                         pattern = paths$param_sample_pattern,
                         full.names = TRUE)

param_samples = do.call(rbind, lapply(param_sample_files, function(f) {
  readRDS(f)
}))

colnames(param_samples) = readRDS(
  dir(path = paths$path_out, pattern = paths$param_sample_column_labels, 
      full.names = TRUE)
)

# associate actively sampled targets with the common parameter names
sampler_groups = lapply(parameter_families, function(pfam) {
  grep(pattern = pfam, x = colnames(param_samples), value = TRUE)
})
names(sampler_groups) = parameter_families
sampler_groups = sampler_groups[order(names(sampler_groups))]

rm(param_sample_files, parameter_families)
```

```{r set_burn}
burn = 1:100
```

# Animals analyzed 

```{r animmal_ids}
print(nim_pkg$consts$subject_id_labels)
```

# Convergence diagnostics

## Traceplots

```{r scaled_trace_fn}
library(ggplot2)
library(ggthemes)
library(dplyr)
library(tidyr)

scaled_trace = function(samples, base_alpha = 1) {
  # Build a traceplot for a collection of variables by scaling/centering each
  # variable in samples.  The resulting plot overlays the scaled and centered 
  # traceplots in a single plot to let users quickly identify if there are any 
  # obvious non-convergence or mixing errors within the collection of variables
  # contained in samples.
  # 
  # Parameters:
  #  samples - matrix of MCMC samples, each row of which is output for one iter.
  
  df = data.frame(iter = 1:nrow(samples), scale(samples)) %>% 
    pivot_longer(cols = -iter, names_to = 'var', values_to = 'val')
  
  ggplot(df, aes(x = iter, y = val, group = var)) + 
    geom_hline(yintercept = 0) + 
    geom_line(alpha = base_alpha/sqrt(ncol(samples))) + 
    xlab('Iteration') + 
    ylab('Scaled parameter') +
    theme_few() + 
    theme(panel.border = element_blank())
}
```

```{r scaled_traces, fig.width=8, fig.height=3}
# prepare to use log-transformations for any variable with "var" in its title
# also return titles
transforms = lapply(names(sampler_groups), function(g) {
  if(grepl(pattern = 'var', x = g)) { c(tx = log, pre = 'log(', post = ')') } 
  else { c(tx = identity, pre = '', post = '') }
})

# plot group traceplots
invisible(mapply(
  function(g, name, tx) {
    print(
      scaled_trace(samples = tx$tx(param_samples[-burn, g, drop = FALSE]), 
                   base_alpha = .7) + 
        ggtitle(paste(tx$pre, name, tx$post, sep = ''))
    )
  }, 
  g = sampler_groups, 
  name = names(sampler_groups), 
  tx = transforms, 
  SIMPLIFY = FALSE
))
```

## Effective sample sizes

```{r ess_summary_plots}
library(coda)
invisible(mapply(
  function(g, name, tx) {
    plot(ecdf(effectiveSize(tx$tx(param_samples[-burn, g, drop = FALSE]))),
         xlab = 'Effective sample size', ylab = 'ECDF', 
         main = paste(tx$pre, name, tx$post, sep = ''))
  }, 
  g = sampler_groups, 
  name = names(sampler_groups), 
  tx = transforms, 
  SIMPLIFY = FALSE
))
```

```{r ess_table_alpha_mu}
# effective sizes (ESS's) for alpha_mu parameters
e = effectiveSize(param_samples[-burn, sampler_groups$lambda])

# extract matrix index descriptions for parameters
arr_inds = do.call(rbind, lapply(names(e), function(tgt) {
  as.numeric(unlist(strsplit(gsub('[A-z\\[\\]]*', '', tgt), ',')))
}))

# initialize container to store ESS's with their parameter labels
m = nim_pkg$inits$lambda * NA

# push ESS's into storage container
for(i in 1:nrow(arr_inds)) {
  m[arr_inds[i,1]] = e[i]
}

m = round(m)

# more compact printing
knitr::kable(t(m), digits = 0, caption = 'ESS for lambda', booktabs = TRUE)
```


# Point estimates for population-level regression effects


```{r pt_ests_fn, fig.}
library(ggplot2)
library(ggthemes)
library(dplyr)
library(tidyr)

pt_ests = function(samples, dimnames) {
  # Parameters:
  #  samples - matrix of MCMC samples, each row of which is output for one iter.

  # posterior HPDs for parameter estimates
  m = mcmc(samples)
  hpds = HPDinterval(m)
  
  # assemble posterior means and HPDs along with labels for parameters
  df = data.frame(
    param = factor(colnames(samples)),
    est = colMeans(m),
    lwr = hpds[,'lower'],
    upr = hpds[,'upper']
  )
  
  ggplot(df, aes(x = param, y = est, ymin = lwr, ymax = upr)) + 
    geom_pointrange() +
    geom_hline(yintercept = 0, lty = 3) + 
    ylab('Regression effect') + 
    theme_few() + 
    theme(axis.title.y = element_blank(),
          panel.grid.major.y = element_line(color = 'grey90')) + 
    coord_flip()
}
```


```{r pt_est_table}
cbind(
  mean = colMeans(mcmc(param_samples[-burn, sampler_groups$lambda, drop = FALSE])),
  HPDinterval(mcmc(param_samples[-burn, sampler_groups$lambda, drop = FALSE]))
)

cor(param_samples[-burn, sampler_groups$lambda])


targets::tar_load(movement_classes)
n_stages = nrow(movement_classes$stage_defs)
m = matrix(NA, nrow = n_stages, ncol = n_stages)
for(i in 1:n_stages) {
  for(j in 1:n_stages) {
    m[i,j] = effectiveSize(mcmc(
      param_samples[-burn, paste('txmat_stages[', i, ', ', j, ']', sep = '')]
    ))
  }
}

rownames(m) = rownames(movement_classes$stage_defs)
colnames(m) = rownames(movement_classes$stage_defs)

round(m,2)
```

```{r pt_ests, dependson='pt_ests_fn', fig.width=8, fig.height=8}
if('beta_mu' %in% names(sampler_groups)) {
  sub_groups = sampler_groups[sort(c('alpha_mu', 'beta_mu', 'betas_tx_mu'))]
} else {
  sub_groups = sampler_groups[sort(c('alpha_mu', 'beta', 'betas_tx'))]
}

sub_groups = sampler_groups

invisible(mapply(
  function(g, name) {
    print(
      pt_ests(samples = param_samples[-burn, g, drop = FALSE], 
              dimnames = 1:length(nim_pkg$inits[[name]])) + 
        ggtitle(name)
    )
  }, 
  g = sub_groups, 
  name = names(sub_groups),
  SIMPLIFY = FALSE
))
```