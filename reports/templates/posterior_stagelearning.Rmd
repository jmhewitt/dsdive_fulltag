---
title: "Posterior stagelearning for multiple sattag fits"
output:
  html_document:
    toc: true
    toc_float:
      collapsed: false
      smooth_scroll: true
      number_sections: true
params:
  nim_pkg_tgt: nim_pkg
  samples: output/mcmc/mcmc_samples_stagelearning.RData
  nburn: 5e3
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, cache = TRUE, message = FALSE, 
                      warning = FALSE)
```


# Configuration

```{r tag_names}
loadd(tag_sex)
tag_names = tag_sex
```

```{r load_model, include = FALSE}
library(nimble)

## Load R files and subplans
lapply(list.files("../../R", full.names = TRUE, recursive = TRUE), source)

# load inputs to target model
loadd(params$nim_pkg_tgt)
nim_pkg = readRDS(file.path('..', '..', get(params$nim_pkg_tgt)))

# build nimble model, so we can extract priors
dive_model = nimbleModel(code = modelCode_stageLearning, 
                         constants = nim_pkg$consts, data = nim_pkg$data, 
                         inits = nim_pkg$inits, name = 'dives')
```

```{r load_samples, include = FALSE}
# load targetted posterior samples
load(file.path('..', '..', params$samples))

samples.names = colnames(samples)

burn = 1:params$nburn
```

This report was generated by the target 
<span style="color:blue">`r id_chr()`</span>, which displays
posterior diagnostics for the samples in 
<span style="color:blue">`r basename(params$samples)`</span>.  The file 
contains <span style="color:blue">`r nrow(samples)`</span> posterior samples.


# Data summary

The data consist of <span style="color:blue">`r nim_pkg$consts$N_dives`</span> deep dives, and <span style="color:blue">`r nim_pkg$consts$N_dives_shallow`</span> shallow dives  across <span style="color:blue">`r nim_pkg$consts$N_tags`</span> tags. The table below shows the distribution of dives per tag.

```{r sample_sizes}
table(nim_pkg$consts$dive_relations[, 'tag'])

summary(as.numeric(table(nim_pkg$consts$dive_relations[, 'tag'])))
```

# Posterior learning

```{r prior_post_plot_fn, include = FALSE}
library(ggplot2)
library(ggthemes)
library(coda)

distn_info = function(pattern, model = NULL, samples, burn, 
                      output = c('prior', 'prior_post', 'trace')) {
  # Parameters:
  #  pattern - string to select nodes
  #  model - nimble model, needed to automatically extract priors
  #  samples - posterior samples
  #  burn - number of samples to discard
  
  # extract model nodes that match the pattern
  tgt = grep(pattern = pattern, x = colnames(samples), value = TRUE)
  
  if(length(burn) == 1) {
    burn = 1:burn
  }
  
  # process matching nodes
  res = lapply(tgt, function(node) {
    
    # initialize output for node
    res = list()
    
    if(TRUE) {
      if(!is.null(model)) {
        
        if(any(c('prior','prior_post') %in% output)) {
          # extract name of distribution for node
          distn = model$getDistribution(node)
          
          # get names of parameters for distribution
          params.names = names(model$getDimension(node, 
                                                  includeParams = TRUE))[-1]
          
          # get values of parameters for distribution
          params.values = sapply(params.names, function(param) {
            model$getParam(node = node, param = param)
          })
          
          # ensure named vector matches the extracted parameters
          names(params.values) = params.names
          
          # base string for evaluating distribution
          base_dist = getDistributionInfo(distn)
          
          # density function
          dfn = eval(
            expr = parse(
              text = paste('function(x) ', base_dist$densityName, '(x, ',
                           paste(base_dist$reqdArgs, collapse = ', '), ')', 
                           sep = '')
            ),
            envir = as.list(params.values)
          )
          
          if(base_dist$pqAvail) {
            # quantile function
            qfn = eval(
              expr = parse(
                text = paste('function(x) q', 
                             substr(base_dist$densityName, 2, 
                                    nchar(base_dist$densityName)), 
                             '(x, ', paste(base_dist$reqdArgs, collapse = ', '),
                             ')', sep = '')
              ),
              envir = as.list(params.values)
            )
            
            # bounds for 95% equal-tailed interval around prior
            qBounds = qfn(c(.01, .99))
          }
          
        }
        
        if('prior' %in% output) {
          # plot prior distribution
          res$prior = ggplot(data.frame(x = qBounds), aes(x = x)) + 
            stat_function(fun = dfn) + 
            theme_few() + 
            theme(panel.border = element_blank()) + 
            xlab(node) + 
            ylab('Density')
        }
        
        if('prior_post' %in% output) {
          
          # extract posterior samples
          post = samples[-burn, node]
          
          # compute posterior summaries
          hpd = HPDinterval(mcmc(post))
          ess = round(effectiveSize(mcmc(post)))
          
          # posterior density estimate, and indices within HPD interval 
          post.density = density(post)
          dens.inds = which(post.density$x >= hpd[1] & post.density$x <= hpd[2])
          
          # plot prior vs posterior comparison
          res$prior_post = ggplot(data.frame(x = post), aes(x = x)) + 
            geom_ribbon(mapping = aes(x = x, ymin = 0, ymax = d),
                        data = data.frame(x = post.density$x, 
                                          d = post.density$y)[dens.inds,],
                        inherit.aes = FALSE, alpha = .125) +
            stat_density(geom = 'line') + 
            stat_function(fun = dfn, lty = 2) + 
            theme_few() + 
            theme(panel.border = element_blank()) + 
            xlab(node) + 
            ylab('Density') + 
            ggtitle(label = 'Prior (dotted) vs. Posterior (solid)', 
                    subtitle = paste('with 95% HPD (shaded); ESS:', 
                                     prettyNum(ess, big.mark = ',')))
        }
        
        # extract posterior samples
        post = samples[-burn, node]
        
        if('trace' %in% output) {
          res$trace = ggplot(data.frame(x = (1:nrow(samples))[-burn], 
                                        y = post), 
                             aes(x = x, y = y)) +
            geom_line() + 
            xlab('Sample') + 
            ylab(node) + 
            theme_few() + 
            theme(panel.border = element_blank())
        } 
        
        if('post' %in% output) {
          
          # compute posterior summaries
          hpd = HPDinterval(mcmc(post))
          ess = round(effectiveSize(mcmc(post)))
          
          # posterior density estimate, and indices within HPD interval 
          post.density = density(post)
          dens.inds = which(post.density$x >= hpd[1] & post.density$x <= hpd[2])
          
          # plot prior vs posterior comparison
          res$post = ggplot(data.frame(x = post), aes(x = x)) + 
            geom_ribbon(mapping = aes(x = x, ymin = 0, ymax = d),
                        data = data.frame(x = post.density$x, 
                                          d = post.density$y)[dens.inds,],
                        inherit.aes = FALSE, alpha = .125) +
            stat_density(geom = 'line') + 
            theme_few() + 
            theme(panel.border = element_blank()) + 
            xlab(node) + 
            ylab('Density') + 
            ggtitle(label = 'Posterior', 
                    subtitle = paste('with 95% HPD (shaded); ESS:', 
                                     prettyNum(ess, big.mark = ',')))
        }
      } else {
        stop('Input model is NA; cannot extract prior distribution')
      }
    }
    
    res
  })
  
  names(res) = tgt
  res
}
```


## Stage duration distributions
  
```{r xi_prior_means}
library(ggpubr)

pl = distn_info(pattern = 'xi_prior_means', model = dive_model, 
                samples = samples, burn = burn, output = 'prior_post')

ggarrange(pl[[1]]$prior_post + 
            geom_vline(xintercept = nim_pkg$inits$xi_prior_means[1], lty = 3), 
          pl[[2]]$prior_post + 
            geom_vline(xintercept = nim_pkg$inits$xi_prior_means[2], lty = 3), 
          ncol = 2)
```

```{r xi_prior_covs}
library(ggpubr)

pl = distn_info(pattern = 'xi_prior_covs\\[1, 1, 1\\]', model = dive_model, 
                samples = samples, burn = burn, output = 'prior_post')

pl2 = distn_info(pattern = 'xi_prior_covs\\[1, 2, 2\\]', model = dive_model, 
                samples = samples, burn = burn, output = 'prior_post')

ggarrange(pl[[1]]$prior_post + 
            geom_vline(xintercept = nim_pkg$inits$xi_prior_covs[1, 1, 1], lty = 3), 
          pl2[[1]]$prior_post + 
            geom_vline(xintercept = nim_pkg$inits$xi_prior_covs[1, 2, 2], lty = 3), 
          ncol = 2)
```

```{r xi_prior_cor}
library(ggpubr)

pl = distn_info(pattern = 'xi_prior_cor_scaled', model = dive_model, 
                samples = samples, burn = burn, output = 'prior_post')

pl[[1]]$prior_post + 
  geom_vline(xintercept = nim_pkg$inits$xi_prior_cor_scaled, lty = 3)
```

```{r xi_shallow_prior}
library(ggpubr)

pl = distn_info(pattern = 'xi_shallow_prior', model = dive_model, 
                samples = samples, burn = burn, output = 'prior_post')

ggarrange(pl[[1]]$prior_post + 
            geom_vline(xintercept = nim_pkg$inits$xi_shallow_prior[1], lty = 3), 
          pl[[2]]$prior_post + 
            geom_vline(xintercept = nim_pkg$inits$xi_shallow_prior[2], lty = 3), 
          ncol = 2)
```


# Posterior predictive distributions

```{r empirical_durations, include = FALSE}
loadd(template_bins)

# reformat deep dive data for 85% rule function
dives.obs = apply(nim_pkg$consts$dive_relations, 1, function(r) {
  list(
    depth.bins = template_bins,
    dive = list(
      depths = nim_pkg$data$depths[r['depth_first']:r['depth_last']],
      times = nim_pkg$data$times[r['depth_first']:r['depth_last']] -
        nim_pkg$data$times[r['depth_first']]
    )
  )
})

# estimate deep dive stage durations by tag
durations.est = cbind(
  times.stages(dives.obs) * 60,
  tag = nim_pkg$consts$dive_relations[,'tag']
)

colnames(durations.est) = c('sub.time.sec', 'bottom.time.sec', 'tag')
  
```

```{r posterior_predictive_durations, include = FALSE}
# draw stage durations from posterior predictive distribution
postpred_stage_durations = data.frame(t(apply(samples[-burn,], 1, function(r) {
  # loop over posteriors for each tag
  do.call(cbind, lapply(1:nim_pkg$consts$N_tags, function(tagId) {
    # identify mean and covariance parameters
    tgt.mean = paste('xi_prior_means[', tagId, ', ',  1:2, ']', sep = '')
    tgt.cov = c(
      paste('xi_prior_covs[', tagId, ', 1, 1]', sep = ''),
      paste('xi_prior_covs[', tagId, ', 1, 2]', sep = ''),
      paste('xi_prior_covs[', tagId, ', 2, 1]', sep = ''),
      paste('xi_prior_covs[', tagId, ', 2, 2]', sep = '')
    )
    # sample stage durations
    exp(
      rmvnorm(n = 1, mean = r[tgt.mean], sigma = matrix(r[tgt.cov], nrow = 2))
    )
  }))
})))

colnames(postpred_stage_durations) = c('sub.time.sec', 'bottom.time.sec')

```

```{r post_pred_durations}
df = rbind(
  cbind(postpred_stage_durations / 60, Density = 'Post. Pred.'),
  cbind(durations.est %>% select(sub.time.sec, bottom.time.sec) / 60, 
        Density = 'Empirical (in-sample)')
)

ggplot(df, aes(x = sub.time.sec, y = bottom.time.sec, col = Density)) + 
  geom_density_2d() +
  scale_color_brewer(type = 'qual', palette = 'Dark2') + 
  xlab('Diving duration (min)') + 
  ylab('Foraging duration (min)') +
  theme_few() + 
  theme(panel.border = element_blank())
```




# Traceplots


## Stage duration distributions
  
```{r xi_prior_means_trace}
library(ggpubr)

pl = distn_info(pattern = 'xi_prior_means', model = dive_model, 
                samples = samples, burn = burn, output = 'trace')

ggarrange(pl[[1]]$trace + 
            geom_hline(yintercept = nim_pkg$inits$xi_prior_means[1], lty = 3), 
          pl[[2]]$trace + 
            geom_hline(yintercept = nim_pkg$inits$xi_prior_means[2], lty = 3), 
          ncol = 2)
```

```{r xi_prior_covs_trace}
library(ggpubr)

pl = distn_info(pattern = 'xi_prior_covs\\[1, 1, 1\\]', model = dive_model, 
                samples = samples, burn = burn, output = 'trace')

pl2 = distn_info(pattern = 'xi_prior_covs\\[1, 2, 2\\]', model = dive_model, 
                samples = samples, burn = burn, output = 'trace')

ggarrange(pl[[1]]$trace + 
            geom_hline(yintercept = nim_pkg$inits$xi_prior_covs[1, 1, 1], lty = 3), 
          pl2[[1]]$prior_post + 
            geom_hline(yintercept = nim_pkg$inits$xi_prior_covs[1, 2, 2], lty = 3), 
          ncol = 2)
```

```{r xi_prior_cor_trace}
library(ggpubr)

pl = distn_info(pattern = 'xi_prior_cor_scaled', model = dive_model, 
                samples = samples, burn = burn, output = 'trace')

pl[[1]]$trace + 
  geom_hline(yintercept = nim_pkg$inits$xi_prior_cor_scaled, lty = 3)
```

```{r xi_shallow_prior_trace}
library(ggpubr)

pl = distn_info(pattern = 'xi_shallow_prior', model = dive_model, 
                samples = samples, burn = burn, output = 'trace')

ggarrange(pl[[1]]$trace + 
            geom_hline(yintercept = nim_pkg$inits$xi_shallow_prior[1], lty = 3), 
          pl[[2]]$trace + 
            geom_hline(yintercept = nim_pkg$inits$xi_shallow_prior[2], lty = 3), 
          ncol = 2)
```
