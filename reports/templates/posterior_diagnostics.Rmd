---
title: "Posterior diagnostics for multiple sattag fits"
output:
  html_document:
    toc: true
    toc_float:
      collapsed: false
      smooth_scroll: true
      number_sections: true
params:
  nim_pkg_tgt: nim_pkg_0
  samples: output/mcmc/mcmc_samples_nim_pkg_0.RData
  nburn: 1e3
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, cache = FALSE, message = FALSE, 
                      warning = FALSE)
```


# Configuration

```{r tag_names}
loadd(tag_sex)
tag_names = tag_sex
```

```{r load_model, include = FALSE}
library(nimble)

## Load R files and subplans
lapply(list.files("../../R", full.names = TRUE, recursive = TRUE), source)

# load inputs to target model
loadd(params$nim_pkg_tgt)
assign('nim_pkg', get(params$nim_pkg_tgt))
rm(list = params$nim_pkg_tgt)

# build nimble model, so we can extract priors
dive_model = nimbleModel(code = modelCode, constants = nim_pkg$consts,
                         data = nim_pkg$data, inits = nim_pkg$inits,
                         name = 'dives')
```

```{r load_samples, include = FALSE}
# load targetted posterior samples
load(file.path('..', '..', params$samples))

samples.names = colnames(samples)

burn = 1:params$nburn
```

This report was generated by the target 
<span style="color:blue">`r id_chr()`</span>, which displays
posterior diagnostics for the samples in 
<span style="color:blue">`r basename(params$samples)`</span>.  The file 
contains <span style="color:blue">`r nrow(samples)`</span> posterior samples.


# Data summary

The data consist of <span style="color:blue">`r nim_pkg$consts$N_dives`</span> dives across <span style="color:blue">`r nim_pkg$consts$N_tags`</span> tags. The table below shows the distribution of dives per tag.

```{r sample_sizes}
table(nim_pkg$consts$dive_relations[, 'tag'])

summary(as.numeric(table(nim_pkg$consts$dive_relations[, 'tag'])))
```

# Posterior learning

## Summary table

```{r summary_table}
library(coda)

samples.names = colnames(samples)



tgt = c(
  paste('pi[', c(1,3), ']', sep = ''),
  grep('_lambda', samples.names, value = TRUE)
)

m = mcmc(samples[-burn, tgt])

s = summary(m)

round(s$statistics, 2)

round(HPDinterval(m), 2)

```

```{r correlations}
# posterior correlations
m.cor = cor(m)

# full matrix
round(m.cor, 2)

sort(abs(m.cor), decreasing = TRUE)

# indices of high-correlation entries
strong.cors = which(abs(m.cor) > .6)

# values of strong correlations
m.cor[strong.cors]

# names of strong correlations (absent diagonal entries)
strong.cors.inds = which( (abs(m.cor) > .6) & m.cor != 1, arr.ind = TRUE)
cbind(row = rownames(m.cor)[strong.cors.inds[,'row']],
      col = colnames(m.cor)[strong.cors.inds[,'col']])

# summary of magnitudes of  remaining correlations
summary(abs(m.cor[-strong.cors]))
```



```{r prior_post_plot_fn, include = FALSE}
library(ggplot2)
library(ggthemes)
library(coda)

distn_info = function(pattern, model = NULL, samples, burn, 
                      output = c('prior', 'prior_post', 'trace')) {
  # Parameters:
  #  pattern - string to select nodes
  #  model - nimble model, needed to automatically extract priors
  #  samples - posterior samples
  #  burn - number of samples to discard
  
  # extract model nodes that match the pattern
  tgt = grep(pattern = pattern, x = colnames(samples), value = TRUE)
  
  if(length(burn) == 1) {
    burn = 1:burn
  }
  
  # process matching nodes
  res = lapply(tgt, function(node) {
    
    # initialize output for node
    res = list()
    
    if(TRUE) {
      if(!is.null(model)) {
        
        if(any(c('prior','prior_post') %in% output)) {
          # extract name of distribution for node
          distn = model$getDistribution(node)
          
          # get names of parameters for distribution
          params.names = names(model$getDimension(node, 
                                                  includeParams = TRUE))[-1]
          
          # get values of parameters for distribution
          params.values = sapply(params.names, function(param) {
            model$getParam(node = node, param = param)
          })
          
          # ensure named vector matches the extracted parameters
          names(params.values) = params.names
          
          # base string for evaluating distribution
          base_dist = getDistributionInfo(distn)
          
          # density function
          dfn = eval(
            expr = parse(
              text = paste('function(x) ', base_dist$densityName, '(x, ',
                           paste(base_dist$reqdArgs, collapse = ', '), ')', 
                           sep = '')
            ),
            envir = as.list(params.values)
          )
          
          if(base_dist$pqAvail) {
            # quantile function
            qfn = eval(
              expr = parse(
                text = paste('function(x) q', 
                             substr(base_dist$densityName, 2, 
                                    nchar(base_dist$densityName)), 
                             '(x, ', paste(base_dist$reqdArgs, collapse = ', '),
                             ')', sep = '')
              ),
              envir = as.list(params.values)
            )
            
            # bounds for 95% equal-tailed interval around prior
            qBounds = qfn(c(.01, .99))
          }
          
        }
        
        if('prior' %in% output) {
          # plot prior distribution
          res$prior = ggplot(data.frame(x = qBounds), aes(x = x)) + 
            stat_function(fun = dfn) + 
            theme_few() + 
            theme(panel.border = element_blank()) + 
            xlab(node) + 
            ylab('Density')
        }
        
        if('prior_post' %in% output) {
          
          # extract posterior samples
          post = samples[-burn, node]
          
          # compute posterior summaries
          hpd = HPDinterval(mcmc(post))
          ess = round(effectiveSize(mcmc(post)))
          
          # posterior density estimate, and indices within HPD interval 
          post.density = density(post)
          dens.inds = which(post.density$x >= hpd[1] & post.density$x <= hpd[2])
          
          # plot prior vs posterior comparison
          res$prior_post = ggplot(data.frame(x = post), aes(x = x)) + 
            geom_ribbon(mapping = aes(x = x, ymin = 0, ymax = d),
                        data = data.frame(x = post.density$x, 
                                          d = post.density$y)[dens.inds,],
                        inherit.aes = FALSE, alpha = .125) +
            stat_density(geom = 'line') + 
            stat_function(fun = dfn, lty = 2) + 
            theme_few() + 
            theme(panel.border = element_blank()) + 
            xlab(node) + 
            ylab('Density') + 
            ggtitle(label = 'Prior (dotted) vs. Posterior (solid)', 
                    subtitle = paste('with 95% HPD (shaded); ESS:', 
                                     prettyNum(ess, big.mark = ',')))
        }
        
        # extract posterior samples
        post = samples[-burn, node]
        
        if('trace' %in% output) {
          res$trace = ggplot(data.frame(x = (1:nrow(samples))[-burn], 
                                        y = post), 
                             aes(x = x, y = y)) +
            geom_line() + 
            xlab('Sample') + 
            ylab(node) + 
            theme_few() + 
            theme(panel.border = element_blank())
        } 
        
        if('post' %in% output) {
          
          # compute posterior summaries
          hpd = HPDinterval(mcmc(post))
          ess = round(effectiveSize(mcmc(post)))
          
          # posterior density estimate, and indices within HPD interval 
          post.density = density(post)
          dens.inds = which(post.density$x >= hpd[1] & post.density$x <= hpd[2])
          
          # plot prior vs posterior comparison
          res$post = ggplot(data.frame(x = post), aes(x = x)) + 
            geom_ribbon(mapping = aes(x = x, ymin = 0, ymax = d),
                        data = data.frame(x = post.density$x, 
                                          d = post.density$y)[dens.inds,],
                        inherit.aes = FALSE, alpha = .125) +
            stat_density(geom = 'line') + 
            theme_few() + 
            theme(panel.border = element_blank()) + 
            xlab(node) + 
            ylab('Density') + 
            ggtitle(label = 'Posterior', 
                    subtitle = paste('with 95% HPD (shaded); ESS:', 
                                     prettyNum(ess, big.mark = ',')))
        }
      } else {
        stop('Input model is NA; cannot extract prior distribution')
      }
    }
    
    res
  })
  
  names(res) = tgt
  res
}
```


## Directional preferences
  
```{r beta_pi, results='hide'}
library(ggpubr)

pl = distn_info(pattern = 'logit_pi\\[[13]\\]', model = dive_model, 
                samples = samples, burn = burn, output = 'prior_post')
```

Descent preferences

```{r beta_pi_descent}
ggarrange(pl$`logit_pi[1]`$prior_post,
          ncol = 2)
```

Ascent preferences

```{r beta_pi_ascent}
ggarrange(pl$`logit_pi[3]`$prior_post,
          ncol = 2)
```


## Vertical speeds


```{r beta_lambda, results='hide'}
pl = distn_info(pattern = 'beta_lambda', model = dive_model, 
                samples = samples, burn = burn, output = 'prior_post')
```

Descent speeds

```{r beta_lambda_descent}
ggarrange(pl$`beta_lambda[1, 1]`$prior_post,
          pl$`beta_lambda[1, 2]`$prior_post,
          ncol = 2)
```

Forage speeds

```{r beta_lambda_forage}
ggarrange(pl$`beta_lambda[2, 1]`$prior_post,
          pl$`beta_lambda[2, 2]`$prior_post,
          ncol = 2)
```

Ascent speeds

```{r beta_lambda_ascent}
ggarrange(pl$`beta_lambda[3, 1]`$prior_post,
          pl$`beta_lambda[3, 2]`$prior_post,
          ncol = 2)
```



Random effect variances

```{r sigma_lambda, results='hide'}
pl = distn_info(pattern = 'sigma_lambda', model = dive_model, 
                samples = samples, burn = burn, output = 'prior_post')

ggarrange(pl$`sigma_lambda[1]`$prior_post + xlab('sigma_lambda[1]^2'),
          pl$`sigma_lambda[2]`$prior_post + xlab('sigma_lambda[2]^2'),
          pl$`sigma_lambda[3]`$prior_post + xlab('sigma_lambda[3]^2'),
          ncol = 2)
```


## Tag-specific parameters
  
  

### Vertical speeds


Descent speeds

```{r tag_lambda1_comparison, results = 'hide'}
library(ggplot2)
library(ggthemes)
library(tidyr)
library(coda)

tgt = grep(pattern = '^lambda\\[[0-9]+, 1\\]', x = samples.names, value = TRUE)

m = mcmc(samples[-burn, tgt])

df = data.frame(id = tag_names$deployid,
                Sex = tag_names$sex,
                mean = colMeans(m, na.rm = TRUE),
                HPDinterval(m, na.rm = TRUE),
                sd = apply(m, 2, function(col) sd(col, na.rm = TRUE)),
                ess = apply(m, 2, function(col) { 
                  effectiveSize(col[is.finite(col)]) } 
                ))

df$id = factor(df$id, levels = levels(df$id)[order(df$sd)])

ggplot(df, aes(x = id, y = mean, ymin = lower, ymax = upper, col = Sex)) +
  geom_pointrange() +
  ylab(expression(lambda[i1])) +
  scale_color_brewer(type = 'qual', palette = 'Dark2') +
  ggtitle(label = 'Posterior means and HPD intervals',
          subtitle = paste('Min. ESS:', min(round(df$ess)))) +
  theme_few() +
  theme(panel.border = element_blank(),
        axis.title.x = element_blank(),
        axis.title.y = element_text(angle = 0, vjust = .5))
```

Forage speeds

```{r tag_lambda2_comparison, results = 'hide'}
library(ggplot2)
library(ggthemes)
library(tidyr)
library(coda)

tgt = grep(pattern = '^lambda\\[[0-9]+, 2\\]', x = samples.names, value = TRUE)

m = mcmc(samples[-burn, tgt])

df = data.frame(id = tag_names$deployid,
                Sex = tag_names$sex,
                mean = colMeans(m, na.rm = TRUE),
                HPDinterval(m, na.rm = TRUE),
                sd = apply(m, 2, function(col) sd(col, na.rm = TRUE)),
                ess = apply(m, 2, function(col) { 
                  effectiveSize(col[is.finite(col)]) } 
                ))

df$id = factor(df$id, levels = levels(df$id)[order(df$sd)])

ggplot(df, aes(x = id, y = mean, ymin = lower, ymax = upper, col = Sex)) +
  geom_pointrange() +
  ylab(expression(lambda[i2])) +
  scale_color_brewer(type = 'qual', palette = 'Dark2') +
  ggtitle(label = 'Posterior means and HPD intervals',
          subtitle = paste('Min. ESS:', min(round(df$ess)))) +
  theme_few() +
  theme(panel.border = element_blank(),
        axis.title.x = element_blank(),
        axis.title.y = element_text(angle = 0, vjust = .5))
```

Ascent speeds

```{r tag_lambda3_comparison, results = 'hide'}
library(ggplot2)
library(ggthemes)
library(tidyr)
library(coda)

tgt = grep(pattern = '^lambda\\[[0-9]+, 3\\]', x = samples.names, value = TRUE)

m = mcmc(samples[-burn, tgt])

df = data.frame(id = tag_names$deployid,
                Sex = tag_names$sex,
                mean = colMeans(m, na.rm = TRUE),
                HPDinterval(m, na.rm = TRUE),
                sd = apply(m, 2, function(col) sd(col, na.rm = TRUE)),
                ess = apply(m, 2, function(col) { 
                  effectiveSize(col[is.finite(col)]) } 
                ))

df$id = factor(df$id, levels = levels(df$id)[order(df$sd)])

ggplot(df, aes(x = id, y = mean, ymin = lower, ymax = upper, col = Sex)) +
  geom_pointrange() +
  ylab(expression(lambda[i3])) +
  scale_color_brewer(type = 'qual', palette = 'Dark2') +
  ggtitle(label = 'Posterior means and HPD intervals',
          subtitle = paste('Min. ESS:', min(round(df$ess)))) +
  theme_few() +
  theme(panel.border = element_blank(),
        axis.title.x = element_blank(),
        axis.title.y = element_text(angle = 0, vjust = .5))
```



Random effect variances

### Additional summaries


Proportion of start/stop offsets that don't move during sampling:

```{r endpoints}

tgt = grep('endpoints', samples.names, value = TRUE)
m = mcmc(samples[-burn, tgt])

stuck.inds = which(apply(m, 2, sd) == 0)

# tgt.stuck = tgt[stuck.inds]
# 
# nodes.affected = dive_model$getDependencies(tgt.stuck)
#   
# dives.affected = unique(as.numeric(
#   gsub(pattern = 'T\\[([0-9]+), [0-9]+\\]', replacement = '\\1', 
#        x =  grep(pattern = 'T\\[[0-9]+, [0-9]+\\]', 
#                  x = nodes.affected, value = TRUE))))
# 
# nim_pkg$consts$dive_relations[, c('T0_endpoint', 'T3_endpoint')]
# 
# which(nim_pkg$consts$dive_relations[, 'depth_first'] == 88)

# a sizeable portion of endpoints didn't mix.  maybe these are the 
# same endpoints that had the bad sampling to begin with?
length(stuck.inds)/length(tgt)

```


Summary stats for effective sample sizes of remaining start/stop offsets:
  
```{r endpoint_ess}
# summary(effectiveSize(m[,-stuck.inds]))
summary(effectiveSize(m))
```

Summary stats for effective sample sizes of stage durations:
  
```{r stage_durations}

tgt = grep('log_xi', samples.names, value = TRUE)
m = mcmc(samples[-burn, tgt])

summary(effectiveSize(m))

```


## Tag-specific random effects

```{r compute_eta_varepsilon, include = FALSE}

samples.additional = t(apply(samples[-burn,], 1, function(r) {
  
  # back-compute vertical speed random effects
  eta = c()
  for(tagInd in 1:nim_pkg$consts$N_tags) {
    eta = c(eta, sapply(1:3, function(s) {
      # extract log(lambda) for given tagInd and stage s
      res = log(r[paste('lambda[', tagInd, ', ', s, ']', sep = '')]) - 
        # # remove intercept
        # r[paste('beta_lambda[', s, ', 1]', sep = '')] - 
        # remove sex covariate
        r[paste('beta_lambda[', s, ', 2]', sep = '')] *
        nim_pkg$consts$tag_covariates[tagInd]
      # format and return result
      names(res) = paste('eta[', tagInd, ', ', s, ']', sep = '')
      res
    }))
  }
  
  eta
}))

samples.additional.names = colnames(samples.additional)

```



### Vertical speeds

Descent random effects

```{r tag_eta1_comparison, results = 'hide', warning = FALSE}
library(ggplot2)
library(ggthemes)
library(tidyr)
library(coda)

tgt = grep(pattern = 'eta\\[[0-9]+, 1\\]', x = samples.additional.names, 
           value = TRUE)

m = mcmc(samples.additional[, tgt])

df = data.frame(id = tag_names$deployid, 
                Sex = tag_names$sex,
                mean = colMeans(m), 
                HPDinterval(m, prob = .9), 
                sd = apply(m, 2, sd))

df$id = factor(df$id, levels = levels(df$id)[order(df$sd)])

ggplot(df, aes(x = id, y = mean, ymin = lower, ymax = upper, col = Sex)) + 
  # geom_hline(yintercept = 0, lty = 3) +
  geom_pointrange() + 
  scale_color_brewer(type = 'qual', palette = 'Dark2') + 
  # ylab(expression(eta[i1])) +
  ylab(expression(alpha[i0]^(1))) +
  ggtitle(label = 'Posterior means and HPD intervals', 
          subtitle = paste('Min. ESS:', min(round(effectiveSize(m))))) + 
  theme_few() + 
  theme(panel.border = element_blank(),
        axis.title.x = element_blank(),
        axis.title.y = element_text(angle = 0, vjust = .5))
```

Forage random effects

```{r tag_eta2_comparison, results = 'hide', warning = FALSE}
library(ggplot2)
library(ggthemes)
library(tidyr)
library(coda)

tgt = grep(pattern = 'eta\\[[0-9]+, 2\\]', x = samples.additional.names, 
           value = TRUE)

m = mcmc(samples.additional[, tgt])

df = data.frame(id = tag_names$deployid, 
                Sex = tag_names$sex,
                mean = colMeans(m), 
                HPDinterval(m, prob = .9), 
                sd = apply(m, 2, sd))

df$id = factor(df$id, levels = levels(df$id)[order(df$sd)])

ggplot(df, aes(x = id, y = mean, ymin = lower, ymax = upper, col = Sex)) + 
  # geom_hline(yintercept = 0, lty = 3) +
  geom_pointrange() + 
  scale_color_brewer(type = 'qual', palette = 'Dark2') + 
  # ylab(expression(eta[i1])) +
  ylab(expression(alpha[i0]^(2))) +
  ggtitle(label = 'Posterior means and HPD intervals', 
          subtitle = paste('Min. ESS:', min(round(effectiveSize(m))))) + 
  theme_few() + 
  theme(panel.border = element_blank(),
        axis.title.x = element_blank(),
        axis.title.y = element_text(angle = 0, vjust = .5))
```

Ascent random effects

```{r tag_eta3_comparison, results = 'hide', warning = FALSE}
library(ggplot2)
library(ggthemes)
library(tidyr)
library(coda)

tgt = grep(pattern = 'eta\\[[0-9]+, 3\\]', x = samples.additional.names, 
           value = TRUE)

m = mcmc(samples.additional[, tgt])

df = data.frame(id = tag_names$deployid, 
                Sex = tag_names$sex,
                mean = colMeans(m), 
                HPDinterval(m, prob = .9), 
                sd = apply(m, 2, sd))

df$id = factor(df$id, levels = levels(df$id)[order(df$sd)])

ggplot(df, aes(x = id, y = mean, ymin = lower, ymax = upper, col = Sex)) + 
  # geom_hline(yintercept = 0, lty = 3) +
  geom_pointrange() + 
  scale_color_brewer(type = 'qual', palette = 'Dark2') + 
  # ylab(expression(eta[i1])) +
  ylab(expression(alpha[i0]^(3))) +
  ggtitle(label = 'Posterior means and HPD intervals', 
          subtitle = paste('Min. ESS:', min(round(effectiveSize(m))))) + 
  theme_few() + 
  theme(panel.border = element_blank(),
        axis.title.x = element_blank(),
        axis.title.y = element_text(angle = 0, vjust = .5))
```





# Posterior diagnostics

## Directional preferences

```{r beta_pi_trace, results='hide'}
distn_info(pattern = 'logit_pi\\[[13]\\]', model = dive_model, 
           samples = samples, burn = burn, output = 'trace')
```



## Vertical speeds

```{r beta_lambda_trace, results='hide'}
distn_info(pattern = 'beta_lambda', model = dive_model, 
           samples = samples, burn = burn, output = 'trace')
```

Traceplot of $log(\sigma_\lambda)$
  
```{r sigma_lambda_trace, results='hide'}
distn_info(pattern = 'sigma_lambda', model = dive_model, 
           samples = log(samples), burn = burn, output = 'trace')
```
